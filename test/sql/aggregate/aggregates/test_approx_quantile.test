# name: test/sql/aggregate/aggregates/test_approx_quantile.test
# description: Test approx quantile operator
# group: [aggregates]

require skip_reload

statement ok
PRAGMA enable_verification

statement ok
PRAGMA verify_external

statement ok
SELECT SETSEED(0.8675309);

statement ok
create table quantile as select range r, random() from range(10000) union all values (NULL, 0.1), (NULL, 0.5), (NULL, 0.9) order by 2;

# Verify that there are two versions of each return type (with and without the count)
query II
SELECT return_type, count(*) AS defined
FROM duckdb_functions()
WHERE function_name = 'reservoir_quantile'
GROUP BY ALL
HAVING defined <> 2
ORDER BY ALL;
----

query I
SELECT CASE
	  WHEN ( approx_quantile between (true_quantile - 100) and (true_quantile + 100) )
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(r, 0.5) as approx_quantile ,quantile(r,0.5) as true_quantile FROM quantile) AS T
----
1


query I
SELECT CASE
	  WHEN ( approx_quantile between (true_quantile - 100) and (true_quantile + 100) )
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(r, 1.0) as approx_quantile ,quantile(r, 1.0) as true_quantile FROM quantile) AS T
----
1

query I
SELECT CASE
	  WHEN ( approx_quantile between (true_quantile - 100) and (true_quantile + 100) )
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(r, 0.0) as approx_quantile ,quantile(r, 0.0) as true_quantile from quantile) AS T
----
1

query II
SELECT approx_quantile(NULL, 0.5)  as approx_quantile ,quantile(NULL, 0.5) as true_quantile
----
NULL	NULL

query I
SELECT CASE
	  WHEN ( approx_quantile between (true_quantile - 100) and (true_quantile + 100) )
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(42, 0.5)  as approx_quantile ,quantile(42, 0.5)  as true_quantile) AS T
----
1

query II
SELECT approx_quantile(NULL, 0.5)  as approx_quantile ,quantile(NULL, 0.5)  as true_quantile FROM quantile
----
NULL	NULL

query II
SELECT approx_quantile(1, 0.5)  as approx_quantile ,quantile(1, 0.5)  as true_quantile FROM quantile
----
1	1

query I
SELECT CASE
	  WHEN ( approx_quantile between (true_quantile - 100) and (true_quantile + 100) )
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(42, 0.5)  as approx_quantile ,quantile(42, 0.5)  as true_quantile) AS T
----
1

query I
SELECT CASE
	  WHEN ( approx_quantile between (true_quantile - 100) and (true_quantile + 100) )
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(r, 0.1)  as approx_quantile ,quantile(r, 0.1)  as true_quantile from quantile) AS T
----
1

query I
SELECT CASE
	  WHEN ( approx_quantile between (true_quantile - 100) and (true_quantile + 100) )
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(r, 0.9)  as approx_quantile ,quantile(r, 0.9)  as true_quantile from quantile) AS T
----
1

# List versions
query I
SELECT [
	(a[1] BETWEEN (q[1] - 100) AND (q[1] + 100)),
	(a[2] BETWEEN (q[2] - 100) AND (q[2] + 100)),
	(a[3] BETWEEN (q[3] - 100) AND (q[3] + 100)),
	]
FROM (
	SELECT approx_quantile(r, [0.25, 0.5, 0.75]) AS a,
		   quantile(r, [0.25, 0.5, 0.75]) AS q,
	FROM quantile
) tbl;
----
[true, true, true]

query I
SELECT [
	(a[1] BETWEEN (q[1] - 100) AND (q[1] + 100)),
	(a[2] BETWEEN (q[2] - 100) AND (q[2] + 100)),
	(a[3] BETWEEN (q[3] - 100) AND (q[3] + 100)),
	]
FROM (
	SELECT reservoir_quantile(r, [0.25, 0.5, 0.75], 4096) AS a,
		   quantile(r, [0.25, 0.5, 0.75]) AS q,
	FROM quantile
) tbl;
----
[true, true, true]

# Errors
statement error
SELECT approx_quantile(r, -0.1) FROM quantile
----
Binder Error: APPROXIMATE QUANTILE can only take parameters in range [0, 1]

statement error
SELECT approx_quantile(r, 1.1) FROM quantile
----
Binder Error: APPROXIMATE QUANTILE can only take parameters in range [0, 1]

statement error
SELECT approx_quantile(r, NULL) FROM quantile
----
Binder Error: APPROXIMATE QUANTILE parameter cannot be NULL

statement error
SELECT approx_quantile(r, r) FROM quantile
----
Binder Error: APPROXIMATE QUANTILE can only take constant quantile parameters

statement error
SELECT approx_quantile(r::string, 0.5) FROM quantile
----
Binder Error: No function matches the given name and argument types 'approx_quantile(VARCHAR, DECIMAL(2,1))'. You might need to add explicit type casts.
	Candidate functions:
	approx_quantile(DECIMAL, FLOAT) -> DECIMAL
	approx_quantile(SMALLINT, FLOAT) -> SMALLINT
	approx_quantile(INTEGER, FLOAT) -> INTEGER
	approx_quantile(BIGINT, FLOAT) -> BIGINT
	approx_quantile(HUGEINT, FLOAT) -> HUGEINT
	approx_quantile(DOUBLE, FLOAT) -> DOUBLE
	approx_quantile(DECIMAL, FLOAT[]) -> DECIMAL[]
	approx_quantile(TINYINT, FLOAT[]) -> TINYINT[]
	approx_quantile(SMALLINT, FLOAT[]) -> SMALLINT[]
	approx_quantile(INTEGER, FLOAT[]) -> INTEGER[]
	approx_quantile(BIGINT, FLOAT[]) -> BIGINT[]
	approx_quantile(HUGEINT, FLOAT[]) -> HUGEINT[]
	approx_quantile(FLOAT, FLOAT[]) -> FLOAT[]
	approx_quantile(DOUBLE, FLOAT[]) -> DOUBLE[]

statement error
SELECT approx_quantile(r) FROM quantile
----
Binder Error: No function matches the given name and argument types 'approx_quantile(BIGINT)'. You might need to add explicit type casts.
	Candidate functions:
	approx_quantile(DECIMAL, FLOAT) -> DECIMAL
	approx_quantile(SMALLINT, FLOAT) -> SMALLINT
	approx_quantile(INTEGER, FLOAT) -> INTEGER
	approx_quantile(BIGINT, FLOAT) -> BIGINT
	approx_quantile(HUGEINT, FLOAT) -> HUGEINT
	approx_quantile(DOUBLE, FLOAT) -> DOUBLE
	approx_quantile(DECIMAL, FLOAT[]) -> DECIMAL[]
	approx_quantile(TINYINT, FLOAT[]) -> TINYINT[]
	approx_quantile(SMALLINT, FLOAT[]) -> SMALLINT[]
	approx_quantile(INTEGER, FLOAT[]) -> INTEGER[]
	approx_quantile(BIGINT, FLOAT[]) -> BIGINT[]
	approx_quantile(HUGEINT, FLOAT[]) -> HUGEINT[]
	approx_quantile(FLOAT, FLOAT[]) -> FLOAT[]
	approx_quantile(DOUBLE, FLOAT[]) -> DOUBLE[]

statement error
SELECT approx_quantile(r, 0.1, 0.2) FROM quantile
----
Binder Error: No function matches the given name and argument types 'approx_quantile(BIGINT, DECIMAL(2,1), DECIMAL(2,1))'. You might need to add explicit type casts.
	Candidate functions:
	approx_quantile(DECIMAL, FLOAT) -> DECIMAL
	approx_quantile(SMALLINT, FLOAT) -> SMALLINT
	approx_quantile(INTEGER, FLOAT) -> INTEGER
	approx_quantile(BIGINT, FLOAT) -> BIGINT
	approx_quantile(HUGEINT, FLOAT) -> HUGEINT
	approx_quantile(DOUBLE, FLOAT) -> DOUBLE
	approx_quantile(DECIMAL, FLOAT[]) -> DECIMAL[]
	approx_quantile(TINYINT, FLOAT[]) -> TINYINT[]
	approx_quantile(SMALLINT, FLOAT[]) -> SMALLINT[]
	approx_quantile(INTEGER, FLOAT[]) -> INTEGER[]
	approx_quantile(BIGINT, FLOAT[]) -> BIGINT[]
	approx_quantile(HUGEINT, FLOAT[]) -> HUGEINT[]
	approx_quantile(FLOAT, FLOAT[]) -> FLOAT[]
	approx_quantile(DOUBLE, FLOAT[]) -> DOUBLE[]

statement ok
pragma threads=4

statement ok
PRAGMA verify_parallelism

query I
SELECT CASE
	  WHEN (approx_quantile between (true_quantile - (sumr * 0.01)) and (true_quantile + (sumr * 0.01)))
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(r, 0.1) as approx_quantile, quantile(r, 0.1) as true_quantile, SUM(r) as sumr from quantile) AS T
----
1

query I
SELECT CASE
	  WHEN (approx_quantile between (true_quantile - (sumr * 0.01)) and (true_quantile + (sumr * 0.01)))
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(r, 0.9) as approx_quantile, quantile(r, 0.9) as true_quantile, SUM(r) as sumr from quantile) AS T
----
1

query I
SELECT CASE
	  WHEN (approx_quantile between (true_quantile - (sumr * 0.01)) and (true_quantile + (sumr * 0.01)))
		  THEN TRUE
		  ELSE FALSE
	  END
	  FROM (SELECT approx_quantile(r, 0.5) as approx_quantile, quantile(r, 0.5) as true_quantile, SUM(r) as sumr from quantile) AS T
----
1

# Test reservoir quantile
statement ok
PRAGMA disable_verification;

statement ok
PRAGMA disable_verify_external;

statement ok
SELECT reservoir_quantile(r, 0.9)  from quantile

statement ok
SELECT reservoir_quantile(r, 0.9,1000)  from quantile

# reservoir = 1
query I
SELECT reservoir_quantile(1, 0.5, 1) FROM quantile
----
1

statement ok
SELECT RESERVOIR_QUANTILE(b, 0.5)
FROM (SELECT 'a' AS a, 1.0 AS b) y
GROUP BY a

statement ok
SELECT APPROX_QUANTILE(b, 0.5)
FROM (
    SELECT 'a' AS a, 1.0 AS b
    UNION ALL SELECT 'a' AS a, 1.0 AS b
    UNION ALL SELECT 'b' AS a, 1.0 AS b
    ) y
GROUP BY a

statement error
SELECT reservoir_quantile(r, r)  from quantile
----
Binder Error: RESERVOIR_QUANTILE can only take constant quantile parameters

statement error
SELECT reservoir_quantile(r, NULL)  from quantile
----
Binder Error: RESERVOIR_QUANTILE QUANTILE parameter cannot be NULL

statement error
SELECT reservoir_quantile(r, r, r)  from quantile
----
Binder Error: No function matches the given name and argument types 'reservoir_quantile(BIGINT, BIGINT, BIGINT)'. You might need to add explicit type casts.
	Candidate functions:
	reservoir_quantile(DECIMAL, DOUBLE) -> DECIMAL
	reservoir_quantile(DECIMAL, DOUBLE, INTEGER) -> DECIMAL
	reservoir_quantile(DECIMAL, DOUBLE[]) -> DECIMAL[]
	reservoir_quantile(DECIMAL, DOUBLE[], INTEGER) -> DECIMAL[]
	reservoir_quantile(TINYINT, DOUBLE) -> TINYINT
	reservoir_quantile(TINYINT, DOUBLE, INTEGER) -> TINYINT
	reservoir_quantile(TINYINT, DOUBLE[]) -> TINYINT[]
	reservoir_quantile(TINYINT, DOUBLE[], INTEGER) -> TINYINT[]
	reservoir_quantile(SMALLINT, DOUBLE) -> SMALLINT
	reservoir_quantile(SMALLINT, DOUBLE, INTEGER) -> SMALLINT
	reservoir_quantile(SMALLINT, DOUBLE[]) -> SMALLINT[]
	reservoir_quantile(SMALLINT, DOUBLE[], INTEGER) -> SMALLINT[]
	reservoir_quantile(INTEGER, DOUBLE) -> INTEGER
	reservoir_quantile(INTEGER, DOUBLE, INTEGER) -> INTEGER
	reservoir_quantile(INTEGER, DOUBLE[]) -> INTEGER[]
	reservoir_quantile(INTEGER, DOUBLE[], INTEGER) -> INTEGER[]
	reservoir_quantile(BIGINT, DOUBLE) -> BIGINT
	reservoir_quantile(BIGINT, DOUBLE, INTEGER) -> BIGINT
	reservoir_quantile(BIGINT, DOUBLE[]) -> BIGINT[]
	reservoir_quantile(BIGINT, DOUBLE[], INTEGER) -> BIGINT[]
	reservoir_quantile(HUGEINT, DOUBLE) -> HUGEINT
	reservoir_quantile(HUGEINT, DOUBLE, INTEGER) -> HUGEINT
	reservoir_quantile(HUGEINT, DOUBLE[]) -> HUGEINT[]
	reservoir_quantile(HUGEINT, DOUBLE[], INTEGER) -> HUGEINT[]
	reservoir_quantile(FLOAT, DOUBLE) -> FLOAT
	reservoir_quantile(FLOAT, DOUBLE, INTEGER) -> FLOAT
	reservoir_quantile(FLOAT, DOUBLE[]) -> FLOAT[]
	reservoir_quantile(FLOAT, DOUBLE[], INTEGER) -> FLOAT[]
	reservoir_quantile(DOUBLE, DOUBLE) -> DOUBLE
	reservoir_quantile(DOUBLE, DOUBLE, INTEGER) -> DOUBLE
	reservoir_quantile(DOUBLE, DOUBLE[]) -> DOUBLE[]
	reservoir_quantile(DOUBLE, DOUBLE[], INTEGER) -> DOUBLE[]

statement error
SELECT reservoir_quantile(r, 0.9, NULL)  from quantile
----
Binder Error: Size of the RESERVOIR_QUANTILE sample cannot be NULL

statement error
SELECT reservoir_quantile(r, 0.9, r)  from quantile
----
Binder Error: No function matches the given name and argument types 'reservoir_quantile(BIGINT, DECIMAL(2,1), BIGINT)'. You might need to add explicit type casts.
	Candidate functions:
	reservoir_quantile(DECIMAL, DOUBLE) -> DECIMAL
	reservoir_quantile(DECIMAL, DOUBLE, INTEGER) -> DECIMAL
	reservoir_quantile(DECIMAL, DOUBLE[]) -> DECIMAL[]
	reservoir_quantile(DECIMAL, DOUBLE[], INTEGER) -> DECIMAL[]
	reservoir_quantile(TINYINT, DOUBLE) -> TINYINT
	reservoir_quantile(TINYINT, DOUBLE, INTEGER) -> TINYINT
	reservoir_quantile(TINYINT, DOUBLE[]) -> TINYINT[]
	reservoir_quantile(TINYINT, DOUBLE[], INTEGER) -> TINYINT[]
	reservoir_quantile(SMALLINT, DOUBLE) -> SMALLINT
	reservoir_quantile(SMALLINT, DOUBLE, INTEGER) -> SMALLINT
	reservoir_quantile(SMALLINT, DOUBLE[]) -> SMALLINT[]
	reservoir_quantile(SMALLINT, DOUBLE[], INTEGER) -> SMALLINT[]
	reservoir_quantile(INTEGER, DOUBLE) -> INTEGER
	reservoir_quantile(INTEGER, DOUBLE, INTEGER) -> INTEGER
	reservoir_quantile(INTEGER, DOUBLE[]) -> INTEGER[]
	reservoir_quantile(INTEGER, DOUBLE[], INTEGER) -> INTEGER[]
	reservoir_quantile(BIGINT, DOUBLE) -> BIGINT
	reservoir_quantile(BIGINT, DOUBLE, INTEGER) -> BIGINT
	reservoir_quantile(BIGINT, DOUBLE[]) -> BIGINT[]
	reservoir_quantile(BIGINT, DOUBLE[], INTEGER) -> BIGINT[]
	reservoir_quantile(HUGEINT, DOUBLE) -> HUGEINT
	reservoir_quantile(HUGEINT, DOUBLE, INTEGER) -> HUGEINT
	reservoir_quantile(HUGEINT, DOUBLE[]) -> HUGEINT[]
	reservoir_quantile(HUGEINT, DOUBLE[], INTEGER) -> HUGEINT[]
	reservoir_quantile(FLOAT, DOUBLE) -> FLOAT
	reservoir_quantile(FLOAT, DOUBLE, INTEGER) -> FLOAT
	reservoir_quantile(FLOAT, DOUBLE[]) -> FLOAT[]
	reservoir_quantile(FLOAT, DOUBLE[], INTEGER) -> FLOAT[]
	reservoir_quantile(DOUBLE, DOUBLE) -> DOUBLE
	reservoir_quantile(DOUBLE, DOUBLE, INTEGER) -> DOUBLE
	reservoir_quantile(DOUBLE, DOUBLE[]) -> DOUBLE[]
	reservoir_quantile(DOUBLE, DOUBLE[], INTEGER) -> DOUBLE[]

statement error
SELECT reservoir_quantile(r, random()::float)  from quantile
----
Binder Error: RESERVOIR_QUANTILE can only take constant quantile parameters

statement error
SELECT reservoir_quantile(r, 0.9, random()::float)  from quantile
----
PLACEHOLDER_ERROR_MESSAGE1538
