# NOTE: this file is generated by tools/pythonpkg/scripts/generate_functions_code.py.
# Do not edit this section manually, your changes will be overwritten!

from duckdb import FunctionExpression


def __internal_compress_integral_ubigint(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_integral_ubigint", col1, col0)


def __internal_compress_integral_uinteger(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_integral_uinteger", col1, col0)


def __internal_compress_integral_usmallint(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_integral_usmallint", col1, col0)


def __internal_compress_integral_utinyint(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_integral_utinyint", col1, col0)


def __internal_compress_string_hugeint(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_string_hugeint", col0)


def __internal_compress_string_ubigint(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_string_ubigint", col0)


def __internal_compress_string_uinteger(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_string_uinteger", col0)


def __internal_compress_string_usmallint(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_string_usmallint", col0)


def __internal_compress_string_utinyint(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_compress_string_utinyint", col0)


def __internal_decompress_integral_bigint(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_decompress_integral_bigint", col1, col0)


def __internal_decompress_integral_hugeint(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_decompress_integral_hugeint", col1, col0)


def __internal_decompress_integral_integer(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_decompress_integral_integer", col1, col0)


def __internal_decompress_integral_smallint(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_decompress_integral_smallint", col1, col0)


def __internal_decompress_integral_ubigint(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_decompress_integral_ubigint", col1, col0)


def __internal_decompress_integral_uinteger(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_decompress_integral_uinteger", col1, col0)


def __internal_decompress_integral_usmallint(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_decompress_integral_usmallint", col1, col0)


def __internal_decompress_string(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("__internal_decompress_string", col0)


def abs(x, /) -> FunctionExpression:
    """Absolute value"""
    return FunctionExpression("abs", x)


def acos(x, /) -> FunctionExpression:
    """Computes the arccosine of x"""
    return FunctionExpression("acos", x)


def add(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None:
        return FunctionExpression("add", col0, col1)
    elif col0 is not None:
        return FunctionExpression("add", col0)
    else:
        raise ValueError('Invalid combination of parameters')


def age(timestamp1=None, timestamp2=None, timestamp=None, /) -> FunctionExpression:
    """Subtract arguments, resulting in the time difference between the two timestamps"""
    if timestamp1 is not None and timestamp2 is not None:
        return FunctionExpression("age", timestamp1, timestamp2)
    elif timestamp is not None:
        return FunctionExpression("age", timestamp)
    else:
        raise ValueError('Invalid combination of parameters')


def aggregate(*args) -> FunctionExpression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("aggregate", *args)


def alias(expr, /) -> FunctionExpression:
    """Returns the name of a given expression"""
    return FunctionExpression("alias", expr)


def any_value(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("any_value", col0)


def approx_count_distinct(x, /) -> FunctionExpression:
    """Computes the approximate count of distinct elements using HyperLogLog."""
    return FunctionExpression("approx_count_distinct", x)


def approx_quantile(pos, x, /) -> FunctionExpression:
    """Computes the approximate quantile using T-Digest."""
    return FunctionExpression("approx_quantile", pos, x)


def arbitrary(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("arbitrary", col0)


def arg_max(val, arg, /) -> FunctionExpression:
    """Finds the row with the maximum val. Calculates the arg expression at that row."""
    return FunctionExpression("arg_max", val, arg)


def arg_min(val, arg, /) -> FunctionExpression:
    """Finds the row with the minimum val. Calculates the arg expression at that row."""
    return FunctionExpression("arg_min", val, arg)


def argmax(val, arg, /) -> FunctionExpression:
    """Finds the row with the maximum val. Calculates the arg expression at that row."""
    return FunctionExpression("argmax", val, arg)


def argmin(val, arg, /) -> FunctionExpression:
    """Finds the row with the minimum val. Calculates the arg expression at that row."""
    return FunctionExpression("argmin", val, arg)


def array_agg(arg, /) -> FunctionExpression:
    """Returns a LIST containing all the values of a column."""
    return FunctionExpression("array_agg", arg)


def array_aggr(*args) -> FunctionExpression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("array_aggr", *args)


def array_aggregate(*args) -> FunctionExpression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("array_aggregate", *args)


def array_append(el, arr, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_append", el, arr)


def array_cat(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_cat", col1, col0)


def array_concat(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_concat", col1, col0)


def array_contains(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_contains", col1, col0)


def array_distinct(list, /) -> FunctionExpression:
    """Removes all duplicates and NULLs from a list. Does not preserve the original
    order"""
    return FunctionExpression("array_distinct", list)


def array_extract(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_extract", col1, col0)


def array_has(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_has", col1, col0)


def array_has_all(l2, l1, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_has_all", l2, l1)


def array_has_any(l2, l1, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_has_any", l2, l1)


def array_indexof(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_indexof", col1, col0)


def array_intersect(l2, l1, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_intersect", l2, l1)


def array_length(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None:
        return FunctionExpression("array_length", col0)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("array_length", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def array_pop_back(arr, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_pop_back", arr)


def array_pop_front(arr, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_pop_front", arr)


def array_position(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_position", col1, col0)


def array_prepend(el, arr, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_prepend", el, arr)


def array_push_back(e, arr, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_push_back", e, arr)


def array_push_front(e, arr, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_push_front", e, arr)


def array_resize(col1, col0, col2=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None:
        return FunctionExpression("array_resize", col0, col1)
    elif col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("array_resize", col0, col1, col2)
    else:
        raise ValueError('Invalid combination of parameters')


def array_reverse(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_reverse", l)


def array_reverse_sort(list, col1=None, /) -> FunctionExpression:
    """Sorts the elements of the list in reverse order"""
    if list is not None:
        return FunctionExpression("array_reverse_sort", list)
    elif list is not None and col1 is not None:
        return FunctionExpression("array_reverse_sort", list, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def array_slice(list, begin, end, step=None, /) -> FunctionExpression:
    """Extract a sublist using slice conventions. Negative values are accepted"""
    if list is not None and begin is not None and end is not None and step is not None:
        return FunctionExpression("array_slice", list, begin, end, step)
    elif list is not None and begin is not None and end is not None:
        return FunctionExpression("array_slice", list, begin, end)
    else:
        raise ValueError('Invalid combination of parameters')


def array_sort(list, col2=None, col1=None, /) -> FunctionExpression:
    """Sorts the elements of the list"""
    if list is not None and col1 is not None:
        return FunctionExpression("array_sort", list, col1)
    elif list is not None:
        return FunctionExpression("array_sort", list)
    elif list is not None and col1 is not None and col2 is not None:
        return FunctionExpression("array_sort", list, col1, col2)
    else:
        raise ValueError('Invalid combination of parameters')


def array_to_json(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("array_to_json", *args)


def array_to_string(sep, arr, /) -> FunctionExpression:
    """"""
    return FunctionExpression("array_to_string", sep, arr)


def array_unique(list, /) -> FunctionExpression:
    """Counts the unique elements of a list"""
    return FunctionExpression("array_unique", list)


def ascii(string, /) -> FunctionExpression:
    """Returns an integer that represents the Unicode code point of the first character
    of the string"""
    return FunctionExpression("ascii", string)


def asin(x, /) -> FunctionExpression:
    """Computes the arcsine of x"""
    return FunctionExpression("asin", x)


def atan(x, /) -> FunctionExpression:
    """Computes the arctangent of x"""
    return FunctionExpression("atan", x)


def atan2(y, x, /) -> FunctionExpression:
    """Computes the arctangent (y, x)"""
    return FunctionExpression("atan2", y, x)


def avg(x, /) -> FunctionExpression:
    """Calculates the average value for all tuples in x."""
    return FunctionExpression("avg", x)


def bar(min, max, x, width=None, /) -> FunctionExpression:
    """Draws a band whose width is proportional to (x - min) and equal to width
    characters when x = max. width defaults to 80"""
    if x is not None and min is not None and max is not None and width is not None:
        return FunctionExpression("bar", x, min, max, width)
    elif x is not None and min is not None and max is not None:
        return FunctionExpression("bar", x, min, max)
    else:
        raise ValueError('Invalid combination of parameters')


def base64(blob, /) -> FunctionExpression:
    """Convert a blob to a base64 encoded string"""
    return FunctionExpression("base64", blob)


def bin(value, /) -> FunctionExpression:
    """Converts the value to binary representation"""
    return FunctionExpression("bin", value)


def bit_and(arg, /) -> FunctionExpression:
    """Returns the bitwise AND of all bits in a given expression."""
    return FunctionExpression("bit_and", arg)


def bit_count(x, /) -> FunctionExpression:
    """Returns the number of bits that are set"""
    return FunctionExpression("bit_count", x)


def bit_length(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("bit_length", col0)


def bit_or(arg, /) -> FunctionExpression:
    """Returns the bitwise OR of all bits in a given expression."""
    return FunctionExpression("bit_or", arg)


def bit_position(substring, bitstring, /) -> FunctionExpression:
    """Returns first starting index of the specified substring within bits, or zero if
    it is not present. The first (leftmost) bit is indexed 1"""
    return FunctionExpression("bit_position", substring, bitstring)


def bit_xor(arg, /) -> FunctionExpression:
    """Returns the bitwise XOR of all bits in a given expression."""
    return FunctionExpression("bit_xor", arg)


def bitstring(length, bitstring, /) -> FunctionExpression:
    """Pads the bitstring until the specified length"""
    return FunctionExpression("bitstring", length, bitstring)


def bitstring_agg(arg, col2=None, col1=None, /) -> FunctionExpression:
    """Returns a bitstring with bits set for each distinct value."""
    if arg is not None:
        return FunctionExpression("bitstring_agg", arg)
    elif arg is not None and col1 is not None and col2 is not None:
        return FunctionExpression("bitstring_agg", arg, col1, col2)
    else:
        raise ValueError('Invalid combination of parameters')


def bool_and(arg, /) -> FunctionExpression:
    """Returns TRUE if every input value is TRUE, otherwise FALSE."""
    return FunctionExpression("bool_and", arg)


def bool_or(arg, /) -> FunctionExpression:
    """Returns TRUE if any input value is TRUE, otherwise FALSE."""
    return FunctionExpression("bool_or", arg)


def cardinality(*args) -> FunctionExpression:
    """Returns the size of the map (or the number of entries in the map)"""
    return FunctionExpression("cardinality", *args)


def cbrt(x, /) -> FunctionExpression:
    """Returns the cube root of x"""
    return FunctionExpression("cbrt", x)


def ceil(x, /) -> FunctionExpression:
    """Rounds the number up"""
    return FunctionExpression("ceil", x)


def ceiling(x, /) -> FunctionExpression:
    """Rounds the number up"""
    return FunctionExpression("ceiling", x)


def century(ts, /) -> FunctionExpression:
    """Extract the century component from a date or timestamp"""
    return FunctionExpression("century", ts)


def chr(code_point, /) -> FunctionExpression:
    """Returns a character which is corresponding the ASCII code value or Unicode code
    point"""
    return FunctionExpression("chr", code_point)


def col_description(table_oid, column_number, /) -> FunctionExpression:
    """"""
    return FunctionExpression("col_description", table_oid, column_number)


def combine(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("combine", col1, col0)


def concat(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("concat", *args)


def concat_ws(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("concat_ws", *args)


def constant_or_null(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("constant_or_null", *args)


def contains(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("contains", col1, col0)


def corr(y, x, /) -> FunctionExpression:
    """Returns the correlation coefficient for non-null pairs in a group."""
    return FunctionExpression("corr", y, x)


def cos(x, /) -> FunctionExpression:
    """Computes the cos of x"""
    return FunctionExpression("cos", x)


def cot(x, /) -> FunctionExpression:
    """Computes the cotangent of x"""
    return FunctionExpression("cot", x)


def count(col0=None, /) -> FunctionExpression:
    """"""
    if col0 is None:
        return FunctionExpression("count")
    elif col0 is not None:
        return FunctionExpression("count", col0)
    else:
        raise ValueError('Invalid combination of parameters')


def count_if(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("count_if", l)


def count_star() -> FunctionExpression:
    """"""
    return FunctionExpression("count_star")


def covar_pop(y, x, /) -> FunctionExpression:
    """Returns the population covariance of input values."""
    return FunctionExpression("covar_pop", y, x)


def covar_samp(y, x, /) -> FunctionExpression:
    """Returns the sample covariance for non-null pairs in a group."""
    return FunctionExpression("covar_samp", y, x)


def current_catalog() -> FunctionExpression:
    """"""
    return FunctionExpression("current_catalog")


def current_database() -> FunctionExpression:
    """Returns the name of the currently active database"""
    return FunctionExpression("current_database")


def current_date() -> FunctionExpression:
    """Returns the current date"""
    return FunctionExpression("current_date")


def current_localtime() -> FunctionExpression:
    """"""
    return FunctionExpression("current_localtime")


def current_localtimestamp() -> FunctionExpression:
    """"""
    return FunctionExpression("current_localtimestamp")


def current_query() -> FunctionExpression:
    """Returns the current query as a string"""
    return FunctionExpression("current_query")


def current_role() -> FunctionExpression:
    """"""
    return FunctionExpression("current_role")


def current_schema() -> FunctionExpression:
    """Returns the name of the currently active schema. Default is main"""
    return FunctionExpression("current_schema")


def current_schemas(include_implicit, /) -> FunctionExpression:
    """Returns list of schemas. Pass a parameter of True to include implicit schemas"""
    return FunctionExpression("current_schemas", include_implicit)


def current_setting(setting_name, /) -> FunctionExpression:
    """Returns the current value of the configuration setting"""
    return FunctionExpression("current_setting", setting_name)


def current_user() -> FunctionExpression:
    """"""
    return FunctionExpression("current_user")


def currval(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("currval", col0)


def damerau_levenshtein(str1, str2, /) -> FunctionExpression:
    """Extension of Levenshtein distance to also include transposition of adjacent
    characters as an allowed edit operation. In other words, the minimum number
    of edit operations (insertions, deletions, substitutions or transpositions)
    required to change one string to another. Different case is considered
    different"""
    return FunctionExpression("damerau_levenshtein", str1, str2)


def date_add(interval, date, /) -> FunctionExpression:
    """"""
    return FunctionExpression("date_add", interval, date)


def date_diff(startdate, part, enddate, /) -> FunctionExpression:
    """The number of partition boundaries between the timestamps"""
    return FunctionExpression("date_diff", startdate, part, enddate)


def date_part(ts, col1, /) -> FunctionExpression:
    """Get subfield (equivalent to extract)"""
    return FunctionExpression("date_part", ts, col1)


def date_sub(startdate, part, enddate, /) -> FunctionExpression:
    """The number of complete partitions between the timestamps"""
    return FunctionExpression("date_sub", startdate, part, enddate)


def date_trunc(part, timestamp, /) -> FunctionExpression:
    """Truncate to specified precision"""
    return FunctionExpression("date_trunc", part, timestamp)


def datediff(startdate, part, enddate, /) -> FunctionExpression:
    """The number of partition boundaries between the timestamps"""
    return FunctionExpression("datediff", startdate, part, enddate)


def datepart(ts, col1, /) -> FunctionExpression:
    """Get subfield (equivalent to extract)"""
    return FunctionExpression("datepart", ts, col1)


def datesub(startdate, part, enddate, /) -> FunctionExpression:
    """The number of complete partitions between the timestamps"""
    return FunctionExpression("datesub", startdate, part, enddate)


def datetrunc(part, timestamp, /) -> FunctionExpression:
    """Truncate to specified precision"""
    return FunctionExpression("datetrunc", part, timestamp)


def day(ts, /) -> FunctionExpression:
    """Extract the day component from a date or timestamp"""
    return FunctionExpression("day", ts)


def dayname(ts, /) -> FunctionExpression:
    """The (English) name of the weekday"""
    return FunctionExpression("dayname", ts)


def dayofmonth(ts, /) -> FunctionExpression:
    """Extract the dayofmonth component from a date or timestamp"""
    return FunctionExpression("dayofmonth", ts)


def dayofweek(ts, /) -> FunctionExpression:
    """Extract the dayofweek component from a date or timestamp"""
    return FunctionExpression("dayofweek", ts)


def dayofyear(ts, /) -> FunctionExpression:
    """Extract the dayofyear component from a date or timestamp"""
    return FunctionExpression("dayofyear", ts)


def decade(ts, /) -> FunctionExpression:
    """Extract the decade component from a date or timestamp"""
    return FunctionExpression("decade", ts)


def decimal(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("decimal", col0)


def decimal_add(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("decimal_add", col1, col0)


def decimal_cmp(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("decimal_cmp", col1, col0)


def decimal_mul(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("decimal_mul", col1, col0)


def decimal_sub(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("decimal_sub", col1, col0)


def decode(blob, /) -> FunctionExpression:
    """Convert blob to varchar. Fails if blob is not valid utf-8"""
    return FunctionExpression("decode", blob)


def degrees(x, /) -> FunctionExpression:
    """Converts radians to degrees"""
    return FunctionExpression("degrees", x)


def divide(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("divide", col1, col0)


def edit(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None:
        return FunctionExpression("edit", col0)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("edit", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def editdist3(str1, str2, /) -> FunctionExpression:
    """The minimum number of single-character edits (insertions, deletions or
    substitutions) required to change one string to the other. Different case is
    considered different"""
    return FunctionExpression("editdist3", str1, str2)


def element_at(*args) -> FunctionExpression:
    """Returns a list containing the value for a given key or an empty list if the key
    is not contained in the map. The type of the key provided in the second
    parameter must match the type of the map’s keys else an error is returned"""
    return FunctionExpression("element_at", *args)


def encode(string, /) -> FunctionExpression:
    """Convert varchar to blob. Converts utf-8 characters into literal encoding"""
    return FunctionExpression("encode", string)


def ends_with(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("ends_with", col1, col0)


def entropy(x, /) -> FunctionExpression:
    """Returns the log-2 entropy of count input-values."""
    return FunctionExpression("entropy", x)


def enum_code(enum, /) -> FunctionExpression:
    """Returns the numeric value backing the given enum value"""
    return FunctionExpression("enum_code", enum)


def enum_first(enum, /) -> FunctionExpression:
    """Returns the first value of the input enum type"""
    return FunctionExpression("enum_first", enum)


def enum_last(enum, /) -> FunctionExpression:
    """Returns the last value of the input enum type"""
    return FunctionExpression("enum_last", enum)


def enum_range(enum, /) -> FunctionExpression:
    """Returns all values of the input enum type as an array"""
    return FunctionExpression("enum_range", enum)


def enum_range_boundary(end, start, /) -> FunctionExpression:
    """Returns the range between the two given enum values as an array. The values must
    be of the same enum type. When the first parameter is NULL, the result
    starts with the first value of the enum type. When the second parameter is
    NULL, the result ends with the last value of the enum type"""
    return FunctionExpression("enum_range_boundary", end, start)


def epoch(temporal, /) -> FunctionExpression:
    """Extract the epoch component from a temporal type"""
    return FunctionExpression("epoch", temporal)


def epoch_ms(temporal, /) -> FunctionExpression:
    """Extract the epoch component in milliseconds from a temporal type"""
    return FunctionExpression("epoch_ms", temporal)


def epoch_ns(temporal, /) -> FunctionExpression:
    """Extract the epoch component in nanoseconds from a temporal type"""
    return FunctionExpression("epoch_ns", temporal)


def epoch_us(temporal, /) -> FunctionExpression:
    """Extract the epoch component in microseconds from a temporal type"""
    return FunctionExpression("epoch_us", temporal)


def era(ts, /) -> FunctionExpression:
    """Extract the era component from a date or timestamp"""
    return FunctionExpression("era", ts)


def error(message, /) -> FunctionExpression:
    """Throws the given error message"""
    return FunctionExpression("error", message)


def even(x, /) -> FunctionExpression:
    """Rounds x to next even number by rounding away from zero"""
    return FunctionExpression("even", x)


def exp(x, /) -> FunctionExpression:
    """Computes e to the power of x"""
    return FunctionExpression("exp", x)


def factorial(x, /) -> FunctionExpression:
    """Factorial of x. Computes the product of the current integer and all integers
    below it"""
    return FunctionExpression("factorial", x)


def favg(x, /) -> FunctionExpression:
    """Calculates the average using a more accurate floating point summation (Kahan
    Sum)"""
    return FunctionExpression("favg", x)


def fdiv(y, x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("fdiv", y, x)


def finalize(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("finalize", col0)


def first(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("first", col0)


def flatten(nested_list, /) -> FunctionExpression:
    """Flatten a nested list by one level"""
    return FunctionExpression("flatten", nested_list)


def floor(x, /) -> FunctionExpression:
    """Rounds the number down"""
    return FunctionExpression("floor", x)


def fmod(y, x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("fmod", y, x)


def format(*args) -> FunctionExpression:
    """Formats a string using fmt syntax"""
    return FunctionExpression("format", *args)


def formatReadableDecimalSize(bytes, /) -> FunctionExpression:
    """Converts bytes to a human-readable presentation (e.g. 16000 -> 16KB)"""
    return FunctionExpression("formatReadableDecimalSize", bytes)


def format_bytes(bytes, /) -> FunctionExpression:
    """Converts bytes to a human-readable presentation (e.g. 16000 -> 16KB)"""
    return FunctionExpression("format_bytes", bytes)


def format_pg_type(type_name, /) -> FunctionExpression:
    """"""
    return FunctionExpression("format_pg_type", type_name)


def format_type(type_oid, typemod, /) -> FunctionExpression:
    """"""
    return FunctionExpression("format_type", type_oid, typemod)


def from_base64(string, /) -> FunctionExpression:
    """Convert a base64 encoded string to a character string"""
    return FunctionExpression("from_base64", string)


def from_binary(value, /) -> FunctionExpression:
    """Converts a value from binary representation to a blob"""
    return FunctionExpression("from_binary", value)


def from_hex(value, /) -> FunctionExpression:
    """Converts a value from hexadecimal representation to a blob"""
    return FunctionExpression("from_hex", value)


def from_json(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("from_json", col1, col0)


def from_json_strict(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("from_json_strict", col1, col0)


def fsum(arg, /) -> FunctionExpression:
    """Calculates the sum using a more accurate floating point summation (Kahan Sum)."""
    return FunctionExpression("fsum", arg)


def gamma(x, /) -> FunctionExpression:
    """Interpolation of (x-1) factorial (so decimal inputs are allowed)"""
    return FunctionExpression("gamma", x)


def gcd(y, x, /) -> FunctionExpression:
    """Computes the greatest common divisor of x and y"""
    return FunctionExpression("gcd", y, x)


def gen_random_uuid() -> FunctionExpression:
    """Returns a random UUID similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687"""
    return FunctionExpression("gen_random_uuid")


def generate_series(start, step=None, stop=None, /) -> FunctionExpression:
    """Create a list of values between start and stop - the stop parameter is inclusive"""
    if start is not None:
        return FunctionExpression("generate_series", start)
    elif start is not None and stop is not None:
        return FunctionExpression("generate_series", start, stop)
    elif start is not None and stop is not None and step is not None:
        return FunctionExpression("generate_series", start, stop, step)
    else:
        raise ValueError('Invalid combination of parameters')


def generate_subscripts(dim, arr, /) -> FunctionExpression:
    """"""
    return FunctionExpression("generate_subscripts", dim, arr)


def geomean(x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("geomean", x)


def geometric_mean(x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("geometric_mean", x)


def get_bit(index, bitstring, /) -> FunctionExpression:
    """Extracts the nth bit from bitstring; the first (leftmost) bit is indexed 0"""
    return FunctionExpression("get_bit", index, bitstring)


def get_current_time() -> FunctionExpression:
    """Returns the current time"""
    return FunctionExpression("get_current_time")


def get_current_timestamp() -> FunctionExpression:
    """Returns the current timestamp"""
    return FunctionExpression("get_current_timestamp")


def greatest(*args) -> FunctionExpression:
    """Returns the highest value of the set of input parameters"""
    return FunctionExpression("greatest", *args)


def greatest_common_divisor(y, x, /) -> FunctionExpression:
    """Computes the greatest common divisor of x and y"""
    return FunctionExpression("greatest_common_divisor", y, x)


def group_concat(str, arg=None, /) -> FunctionExpression:
    """Concatenates the column string values with an optional separator."""
    if str is not None:
        return FunctionExpression("group_concat", str)
    elif str is not None and arg is not None:
        return FunctionExpression("group_concat", str, arg)
    else:
        raise ValueError('Invalid combination of parameters')


def hamming(str1, str2, /) -> FunctionExpression:
    """The number of positions with different characters for 2 strings of equal length.
    Different case is considered different"""
    return FunctionExpression("hamming", str1, str2)


def has_any_column_privilege(privilege, table, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_any_column_privilege", privilege, table)


def has_column_privilege(column, privilege, table, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_column_privilege", column, privilege, table)


def has_database_privilege(privilege, database, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_database_privilege", privilege, database)


def has_foreign_data_wrapper_privilege(privilege, fdw, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_foreign_data_wrapper_privilege", privilege, fdw)


def has_function_privilege(privilege, function, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_function_privilege", privilege, function)


def has_language_privilege(privilege, language, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_language_privilege", privilege, language)


def has_schema_privilege(schema, privilege, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_schema_privilege", schema, privilege)


def has_sequence_privilege(privilege, sequence, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_sequence_privilege", privilege, sequence)


def has_server_privilege(server, privilege, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_server_privilege", server, privilege)


def has_table_privilege(privilege, table, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_table_privilege", privilege, table)


def has_tablespace_privilege(privilege, tablespace, /) -> FunctionExpression:
    """"""
    return FunctionExpression("has_tablespace_privilege", privilege, tablespace)


def hash(*args) -> FunctionExpression:
    """Returns an integer with the hash of the value. Note that this is not a
    cryptographic hash"""
    return FunctionExpression("hash", *args)


def hex(value, /) -> FunctionExpression:
    """Converts the value to hexadecimal representation"""
    return FunctionExpression("hex", value)


def histogram(arg, /) -> FunctionExpression:
    """Returns a LIST of STRUCTs with the fields bucket and count."""
    return FunctionExpression("histogram", arg)


def hour(ts, /) -> FunctionExpression:
    """Extract the hour component from a date or timestamp"""
    return FunctionExpression("hour", ts)


def icu_sort_key(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("icu_sort_key", col1, col0)


def ieee754(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None:
        return FunctionExpression("ieee754", col0, col1)
    elif col0 is not None:
        return FunctionExpression("ieee754", col0)
    else:
        raise ValueError('Invalid combination of parameters')


def ieee754_exponent(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("ieee754_exponent", col0)


def ieee754_from_blob(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("ieee754_from_blob", col0)


def ieee754_mantissa(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("ieee754_mantissa", col0)


def ieee754_to_blob(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("ieee754_to_blob", col0)


def ilike_escape(col2, col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("ilike_escape", col2, col1, col0)


def in_search_path(database_name, schema_name, /) -> FunctionExpression:
    """Returns whether or not the database/schema are in the search path"""
    return FunctionExpression("in_search_path", database_name, schema_name)


def inet_client_addr() -> FunctionExpression:
    """"""
    return FunctionExpression("inet_client_addr")


def inet_client_port() -> FunctionExpression:
    """"""
    return FunctionExpression("inet_client_port")


def inet_server_addr() -> FunctionExpression:
    """"""
    return FunctionExpression("inet_server_addr")


def inet_server_port() -> FunctionExpression:
    """"""
    return FunctionExpression("inet_server_port")


def instr(haystack, needle, /) -> FunctionExpression:
    """Returns location of first occurrence of needle in haystack, counting from 1.
    Returns 0 if no match found"""
    return FunctionExpression("instr", haystack, needle)


def isfinite(x, /) -> FunctionExpression:
    """Returns true if the floating point value is finite, false otherwise"""
    return FunctionExpression("isfinite", x)


def isinf(x, /) -> FunctionExpression:
    """Returns true if the floating point value is infinite, false otherwise"""
    return FunctionExpression("isinf", x)


def isnan(x, /) -> FunctionExpression:
    """Returns true if the floating point value is not a number, false otherwise"""
    return FunctionExpression("isnan", x)


def isodow(ts, /) -> FunctionExpression:
    """Extract the isodow component from a date or timestamp"""
    return FunctionExpression("isodow", ts)


def isoyear(ts, /) -> FunctionExpression:
    """Extract the isoyear component from a date or timestamp"""
    return FunctionExpression("isoyear", ts)


def jaccard(str1, str2, /) -> FunctionExpression:
    """The Jaccard similarity between two strings. Different case is considered
    different. Returns a number between 0 and 1"""
    return FunctionExpression("jaccard", str1, str2)


def jaro_similarity(str1, str2, /) -> FunctionExpression:
    """The Jaro similarity between two strings. Different case is considered different.
    Returns a number between 0 and 1"""
    return FunctionExpression("jaro_similarity", str1, str2)


def jaro_winkler_similarity(str1, str2, /) -> FunctionExpression:
    """The Jaro-Winkler similarity between two strings. Different case is considered
    different. Returns a number between 0 and 1"""
    return FunctionExpression("jaro_winkler_similarity", str1, str2)


def json(x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json", x)


def json_array(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("json_array", *args)


def json_array_length(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None:
        return FunctionExpression("json_array_length", col0)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("json_array_length", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def json_contains(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_contains", col1, col0)


def json_deserialize_sql(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_deserialize_sql", col0)


def json_extract(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_extract", col1, col0)


def json_extract_path(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_extract_path", col1, col0)


def json_extract_path_text(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_extract_path_text", col1, col0)


def json_extract_string(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_extract_string", col1, col0)


def json_group_array(x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_group_array", x)


def json_group_object(name, value, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_group_object", name, value)


def json_group_structure(x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_group_structure", x)


def json_keys(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None:
        return FunctionExpression("json_keys", col0)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("json_keys", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def json_merge_patch(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("json_merge_patch", *args)


def json_object(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("json_object", *args)


def json_quote(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("json_quote", *args)


def json_serialize_sql(col0, col2=None, col1=None, col3=None, /) -> FunctionExpression:
    """"""
    if col0 is not None:
        return FunctionExpression("json_serialize_sql", col0)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("json_serialize_sql", col0, col1)
    elif col0 is not None and col1 is not None and col2 is not None and col3 is not None:
        return FunctionExpression("json_serialize_sql", col0, col1, col2, col3)
    elif col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("json_serialize_sql", col0, col1, col2)
    else:
        raise ValueError('Invalid combination of parameters')


def json_structure(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_structure", col0)


def json_transform(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_transform", col1, col0)


def json_transform_strict(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_transform_strict", col1, col0)


def json_type(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None:
        return FunctionExpression("json_type", col0)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("json_type", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def json_valid(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("json_valid", col0)


def julian(ts, /) -> FunctionExpression:
    """Extract the Julian Day number from a date or timestamp"""
    return FunctionExpression("julian", ts)


def kahan_sum(arg, /) -> FunctionExpression:
    """Calculates the sum using a more accurate floating point summation (Kahan Sum)."""
    return FunctionExpression("kahan_sum", arg)


def kurtosis(x, /) -> FunctionExpression:
    """Returns the excess kurtosis (Fisher’s definition) of all input values, with a
    bias correction according to the sample size"""
    return FunctionExpression("kurtosis", x)


def last(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("last", col0)


def last_day(ts, /) -> FunctionExpression:
    """Returns the last day of the month"""
    return FunctionExpression("last_day", ts)


def lcase(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("lcase", col0)


def lcm(y, x, /) -> FunctionExpression:
    """Computes the least common multiple of x and y"""
    return FunctionExpression("lcm", y, x)


def least(*args) -> FunctionExpression:
    """Returns the lowest value of the set of input parameters"""
    return FunctionExpression("least", *args)


def least_common_multiple(y, x, /) -> FunctionExpression:
    """Computes the least common multiple of x and y"""
    return FunctionExpression("least_common_multiple", y, x)


def left(string, count, /) -> FunctionExpression:
    """Extract the left-most count characters"""
    return FunctionExpression("left", string, count)


def left_grapheme(string, count, /) -> FunctionExpression:
    """Extract the left-most count grapheme clusters"""
    return FunctionExpression("left_grapheme", string, count)


def len(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("len", col0)


def length(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("length", col0)


def length_grapheme(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("length_grapheme", col0)


def levenshtein(str1, str2, /) -> FunctionExpression:
    """The minimum number of single-character edits (insertions, deletions or
    substitutions) required to change one string to the other. Different case is
    considered different"""
    return FunctionExpression("levenshtein", str1, str2)


def lgamma(x, /) -> FunctionExpression:
    """Computes the log of the gamma function"""
    return FunctionExpression("lgamma", x)


def like_escape(col2, col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("like_escape", col2, col1, col0)


def list(arg, /) -> FunctionExpression:
    """Returns a LIST containing all the values of a column."""
    return FunctionExpression("list", arg)


def list_aggr(*args) -> FunctionExpression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("list_aggr", *args)


def list_aggregate(*args) -> FunctionExpression:
    """Executes the aggregate function name on the elements of list"""
    return FunctionExpression("list_aggregate", *args)


def list_any_value(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_any_value", l)


def list_append(e, l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_append", e, l)


def list_approx_count_distinct(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_approx_count_distinct", l)


def list_avg(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_avg", l)


def list_bit_and(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_bit_and", l)


def list_bit_or(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_bit_or", l)


def list_bit_xor(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_bit_xor", l)


def list_bool_and(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_bool_and", l)


def list_bool_or(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_bool_or", l)


def list_cat(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_cat", col1, col0)


def list_concat(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_concat", col1, col0)


def list_contains(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_contains", col1, col0)


def list_cosine_similarity(list2, list1, /) -> FunctionExpression:
    """Compute the cosine similarity between two lists"""
    return FunctionExpression("list_cosine_similarity", list2, list1)


def list_count(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_count", l)


def list_distance(list2, list1, /) -> FunctionExpression:
    """Compute the distance between two lists"""
    return FunctionExpression("list_distance", list2, list1)


def list_distinct(list, /) -> FunctionExpression:
    """Removes all duplicates and NULLs from a list. Does not preserve the original
    order"""
    return FunctionExpression("list_distinct", list)


def list_dot_product(list2, list1, /) -> FunctionExpression:
    """Compute the inner product between two lists"""
    return FunctionExpression("list_dot_product", list2, list1)


def list_element(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_element", col1, col0)


def list_entropy(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_entropy", l)


def list_extract(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_extract", col1, col0)


def list_first(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_first", l)


def list_has(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_has", col1, col0)


def list_has_all(l2, l1, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_has_all", l2, l1)


def list_has_any(l2, l1, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_has_any", l2, l1)


def list_histogram(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_histogram", l)


def list_indexof(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_indexof", col1, col0)


def list_inner_product(list2, list1, /) -> FunctionExpression:
    """Compute the inner product between two lists"""
    return FunctionExpression("list_inner_product", list2, list1)


def list_intersect(l2, l1, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_intersect", l2, l1)


def list_kurtosis(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_kurtosis", l)


def list_last(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_last", l)


def list_mad(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_mad", l)


def list_max(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_max", l)


def list_median(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_median", l)


def list_min(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_min", l)


def list_mode(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_mode", l)


def list_pack(*args) -> FunctionExpression:
    """Create a LIST containing the argument values"""
    return FunctionExpression("list_pack", *args)


def list_position(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_position", col1, col0)


def list_prepend(e, l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_prepend", e, l)


def list_product(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_product", l)


def list_resize(col1, col0, col2=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None:
        return FunctionExpression("list_resize", col0, col1)
    elif col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("list_resize", col0, col1, col2)
    else:
        raise ValueError('Invalid combination of parameters')


def list_reverse(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_reverse", l)


def list_reverse_sort(list, col1=None, /) -> FunctionExpression:
    """Sorts the elements of the list in reverse order"""
    if list is not None and col1 is not None:
        return FunctionExpression("list_reverse_sort", list, col1)
    elif list is not None:
        return FunctionExpression("list_reverse_sort", list)
    else:
        raise ValueError('Invalid combination of parameters')


def list_sem(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_sem", l)


def list_skewness(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_skewness", l)


def list_slice(list, begin, end, step=None, /) -> FunctionExpression:
    """Extract a sublist using slice conventions. Negative values are accepted"""
    if list is not None and begin is not None and end is not None and step is not None:
        return FunctionExpression("list_slice", list, begin, end, step)
    elif list is not None and begin is not None and end is not None:
        return FunctionExpression("list_slice", list, begin, end)
    else:
        raise ValueError('Invalid combination of parameters')


def list_sort(list, col2=None, col1=None, /) -> FunctionExpression:
    """Sorts the elements of the list"""
    if list is not None and col1 is not None:
        return FunctionExpression("list_sort", list, col1)
    elif list is not None and col1 is not None and col2 is not None:
        return FunctionExpression("list_sort", list, col1, col2)
    elif list is not None:
        return FunctionExpression("list_sort", list)
    else:
        raise ValueError('Invalid combination of parameters')


def list_stddev_pop(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_stddev_pop", l)


def list_stddev_samp(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_stddev_samp", l)


def list_string_agg(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_string_agg", l)


def list_sum(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_sum", l)


def list_unique(list, /) -> FunctionExpression:
    """Counts the unique elements of a list"""
    return FunctionExpression("list_unique", list)


def list_value(*args) -> FunctionExpression:
    """Create a LIST containing the argument values"""
    return FunctionExpression("list_value", *args)


def list_var_pop(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_var_pop", l)


def list_var_samp(l, /) -> FunctionExpression:
    """"""
    return FunctionExpression("list_var_samp", l)


def ln(x, /) -> FunctionExpression:
    """Computes the natural logarithm of x"""
    return FunctionExpression("ln", x)


def log(x, /) -> FunctionExpression:
    """Computes the 10-log of x"""
    return FunctionExpression("log", x)


def log10(x, /) -> FunctionExpression:
    """Computes the 10-log of x"""
    return FunctionExpression("log10", x)


def log2(x, /) -> FunctionExpression:
    """Computes the 2-log of x"""
    return FunctionExpression("log2", x)


def lower(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("lower", col0)


def lpad(string, character, count, /) -> FunctionExpression:
    """Pads the string with the character from the left until it has count characters"""
    return FunctionExpression("lpad", string, character, count)


def lsmode(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("lsmode", col0)


def ltrim(string, characters=None, /) -> FunctionExpression:
    """Removes any occurrences of any of the characters from the left side of the
    string"""
    if string is not None and characters is not None:
        return FunctionExpression("ltrim", string, characters)
    elif string is not None:
        return FunctionExpression("ltrim", string)
    else:
        raise ValueError('Invalid combination of parameters')


def mad(x, /) -> FunctionExpression:
    """Returns the median absolute deviation for the values within x. NULL values are
    ignored. Temporal types return a positive INTERVAL."""
    return FunctionExpression("mad", x)


def make_date(year, month=None, day=None, /) -> FunctionExpression:
    """The date for the given parts"""
    if year is not None and month is not None and day is not None:
        return FunctionExpression("make_date", year, month, day)
    elif year is not None:
        return FunctionExpression("make_date", year)
    else:
        raise ValueError('Invalid combination of parameters')


def make_time(minute, seconds, hour, /) -> FunctionExpression:
    """The time for the given parts"""
    return FunctionExpression("make_time", minute, seconds, hour)


def make_timestamp(year, month=None, day=None, minute=None, seconds=None, hour=None, /) -> FunctionExpression:
    """The timestamp for the given parts"""
    if year is not None:
        return FunctionExpression("make_timestamp", year)
    elif year is not None and month is not None and day is not None and hour is not None and minute is not None and seconds is not None:
        return FunctionExpression("make_timestamp", year, month, day, hour, minute, seconds)
    else:
        raise ValueError('Invalid combination of parameters')


def make_timestamptz(col0, col6=None, col2=None, col1=None, col3=None, col5=None, col4=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None and col3 is not None and col4 is not None and col5 is not None:
        return FunctionExpression("make_timestamptz", col0, col1, col2, col3, col4, col5)
    elif col0 is not None:
        return FunctionExpression("make_timestamptz", col0)
    elif col0 is not None and col1 is not None and col2 is not None and col3 is not None and col4 is not None and col5 is not None and col6 is not None:
        return FunctionExpression("make_timestamptz", col0, col1, col2, col3, col4, col5, col6)
    else:
        raise ValueError('Invalid combination of parameters')


def map(*args) -> FunctionExpression:
    """Creates a map from a set of keys and values"""
    return FunctionExpression("map", *args)


def map_concat(*args) -> FunctionExpression:
    """Returns a map created from merging the input maps, on key collision the value is
    taken from the last map with that key"""
    return FunctionExpression("map_concat", *args)


def map_entries(*args) -> FunctionExpression:
    """Returns the map entries as a list of keys/values"""
    return FunctionExpression("map_entries", *args)


def map_extract(*args) -> FunctionExpression:
    """Returns a list containing the value for a given key or an empty list if the key
    is not contained in the map. The type of the key provided in the second
    parameter must match the type of the map’s keys else an error is returned"""
    return FunctionExpression("map_extract", *args)


def map_from_entries(*args) -> FunctionExpression:
    """Returns a map created from the entries of the array"""
    return FunctionExpression("map_from_entries", *args)


def map_keys(*args) -> FunctionExpression:
    """Returns the keys of a map as a list"""
    return FunctionExpression("map_keys", *args)


def map_values(*args) -> FunctionExpression:
    """Returns the values of a map as a list"""
    return FunctionExpression("map_values", *args)


def max(arg, /) -> FunctionExpression:
    """Returns the maximum value present in arg."""
    return FunctionExpression("max", arg)


def max_by(val, arg, /) -> FunctionExpression:
    """Finds the row with the maximum val. Calculates the arg expression at that row."""
    return FunctionExpression("max_by", val, arg)


def md5(value, /) -> FunctionExpression:
    """Returns the MD5 hash of the value as a string"""
    return FunctionExpression("md5", value)


def md5_number(value, /) -> FunctionExpression:
    """Returns the MD5 hash of the value as an INT128"""
    return FunctionExpression("md5_number", value)


def md5_number_lower(value, /) -> FunctionExpression:
    """Returns the MD5 hash of the value as an INT128"""
    return FunctionExpression("md5_number_lower", value)


def md5_number_upper(value, /) -> FunctionExpression:
    """Returns the MD5 hash of the value as an INT128"""
    return FunctionExpression("md5_number_upper", value)


def mean(x, /) -> FunctionExpression:
    """Calculates the average value for all tuples in x."""
    return FunctionExpression("mean", x)


def median(x, /) -> FunctionExpression:
    """Returns the middle value of the set. NULL values are ignored. For even value
    counts, quantitiative values are averaged and ordinal values return the
    lower value."""
    return FunctionExpression("median", x)


def microsecond(ts, /) -> FunctionExpression:
    """Extract the microsecond component from a date or timestamp"""
    return FunctionExpression("microsecond", ts)


def millennium(ts, /) -> FunctionExpression:
    """Extract the millennium component from a date or timestamp"""
    return FunctionExpression("millennium", ts)


def millisecond(ts, /) -> FunctionExpression:
    """Extract the millisecond component from a date or timestamp"""
    return FunctionExpression("millisecond", ts)


def min(arg, /) -> FunctionExpression:
    """Returns the minimum value present in arg."""
    return FunctionExpression("min", arg)


def min_by(val, arg, /) -> FunctionExpression:
    """Finds the row with the minimum val. Calculates the arg expression at that row."""
    return FunctionExpression("min_by", val, arg)


def minute(ts, /) -> FunctionExpression:
    """Extract the minute component from a date or timestamp"""
    return FunctionExpression("minute", ts)


def mismatches(str1, str2, /) -> FunctionExpression:
    """The number of positions with different characters for 2 strings of equal length.
    Different case is considered different"""
    return FunctionExpression("mismatches", str1, str2)


def mod(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("mod", col1, col0)


def mode(x, /) -> FunctionExpression:
    """Returns the most frequent value for the values within x. NULL values are
    ignored."""
    return FunctionExpression("mode", x)


def month(ts, /) -> FunctionExpression:
    """Extract the month component from a date or timestamp"""
    return FunctionExpression("month", ts)


def monthname(ts, /) -> FunctionExpression:
    """The (English) name of the month"""
    return FunctionExpression("monthname", ts)


def multiply(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("multiply", col1, col0)


def nextafter(y, x, /) -> FunctionExpression:
    """Returns the next floating point value after x in the direction of y"""
    return FunctionExpression("nextafter", y, x)


def nextval(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("nextval", col0)


def nfc_normalize(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("nfc_normalize", col0)


def not_ilike_escape(col2, col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("not_ilike_escape", col2, col1, col0)


def not_like_escape(col2, col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("not_like_escape", col2, col1, col0)


def now() -> FunctionExpression:
    """Returns the current timestamp"""
    return FunctionExpression("now")


def nullif(b, a, /) -> FunctionExpression:
    """"""
    return FunctionExpression("nullif", b, a)


def obj_description(catalog_name, object_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("obj_description", catalog_name, object_oid)


def octet_length(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("octet_length", col0)


def ord(str, /) -> FunctionExpression:
    """Returns the unicode codepoint of the first character of the string"""
    return FunctionExpression("ord", str)


def pg_collation_is_visible(collation_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_collation_is_visible", collation_oid)


def pg_conf_load_time() -> FunctionExpression:
    """"""
    return FunctionExpression("pg_conf_load_time")


def pg_conversion_is_visible(conversion_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_conversion_is_visible", conversion_oid)


def pg_function_is_visible(function_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_function_is_visible", function_oid)


def pg_get_constraintdef(constraint_oid, pretty_bool, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_get_constraintdef", constraint_oid, pretty_bool)


def pg_get_expr(pg_node_tree, relation_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_get_expr", pg_node_tree, relation_oid)


def pg_get_viewdef(oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_get_viewdef", oid)


def pg_has_role(privilege, role, user, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_has_role", privilege, role, user)


def pg_is_other_temp_schema(schema_id, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_is_other_temp_schema", schema_id)


def pg_my_temp_schema() -> FunctionExpression:
    """"""
    return FunctionExpression("pg_my_temp_schema")


def pg_opclass_is_visible(opclass_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_opclass_is_visible", opclass_oid)


def pg_operator_is_visible(operator_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_operator_is_visible", operator_oid)


def pg_opfamily_is_visible(opclass_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_opfamily_is_visible", opclass_oid)


def pg_postmaster_start_time() -> FunctionExpression:
    """"""
    return FunctionExpression("pg_postmaster_start_time")


def pg_size_pretty(bytes, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_size_pretty", bytes)


def pg_table_is_visible(table_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_table_is_visible", table_oid)


def pg_ts_config_is_visible(config_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_ts_config_is_visible", config_oid)


def pg_ts_dict_is_visible(dict_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_ts_dict_is_visible", dict_oid)


def pg_ts_parser_is_visible(parser_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_ts_parser_is_visible", parser_oid)


def pg_ts_template_is_visible(template_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_ts_template_is_visible", template_oid)


def pg_type_is_visible(type_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_type_is_visible", type_oid)


def pg_typeof(expression, /) -> FunctionExpression:
    """"""
    return FunctionExpression("pg_typeof", expression)


def pi() -> FunctionExpression:
    """Returns the value of pi"""
    return FunctionExpression("pi")


def position(haystack, needle, /) -> FunctionExpression:
    """Returns location of first occurrence of needle in haystack, counting from 1.
    Returns 0 if no match found"""
    return FunctionExpression("position", haystack, needle)


def pow(y, x, /) -> FunctionExpression:
    """Computes x to the power of y"""
    return FunctionExpression("pow", y, x)


def power(y, x, /) -> FunctionExpression:
    """Computes x to the power of y"""
    return FunctionExpression("power", y, x)


def prefix(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("prefix", col1, col0)


def printf(*args) -> FunctionExpression:
    """Formats a string using printf syntax"""
    return FunctionExpression("printf", *args)


def product(arg, /) -> FunctionExpression:
    """Calculates the product of all tuples in arg."""
    return FunctionExpression("product", arg)


def quantile(pos, x, /) -> FunctionExpression:
    """Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs,
    then the result is a LIST of the corresponding exact quantiles."""
    return FunctionExpression("quantile", pos, x)


def quantile_cont(pos, x, /) -> FunctionExpression:
    """Returns the intepolated quantile number between 0 and 1 . If pos is a LIST of
    FLOATs, then the result is a LIST of the corresponding intepolated
    quantiles."""
    return FunctionExpression("quantile_cont", pos, x)


def quantile_disc(pos, x, /) -> FunctionExpression:
    """Returns the exact quantile number between 0 and 1 . If pos is a LIST of FLOATs,
    then the result is a LIST of the corresponding exact quantiles."""
    return FunctionExpression("quantile_disc", pos, x)


def quarter(ts, /) -> FunctionExpression:
    """Extract the quarter component from a date or timestamp"""
    return FunctionExpression("quarter", ts)


def radians(x, /) -> FunctionExpression:
    """Converts degrees to radians"""
    return FunctionExpression("radians", x)


def random() -> FunctionExpression:
    """Returns a random number between 0 and 1"""
    return FunctionExpression("random")


def range(start, step=None, stop=None, /) -> FunctionExpression:
    """Create a list of values between start and stop - the stop parameter is exclusive"""
    if start is not None and stop is not None and step is not None:
        return FunctionExpression("range", start, stop, step)
    elif start is not None:
        return FunctionExpression("range", start)
    elif start is not None and stop is not None:
        return FunctionExpression("range", start, stop)
    else:
        raise ValueError('Invalid combination of parameters')


def readfile(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("readfile", col0)


def regexp_extract(col1, col0, col2=None, col3=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("regexp_extract", col0, col1, col2)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("regexp_extract", col0, col1)
    elif col0 is not None and col1 is not None and col2 is not None and col3 is not None:
        return FunctionExpression("regexp_extract", col0, col1, col2, col3)
    else:
        raise ValueError('Invalid combination of parameters')


def regexp_extract_all(col1, col0, col2=None, col3=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("regexp_extract_all", col0, col1, col2)
    elif col0 is not None and col1 is not None and col2 is not None and col3 is not None:
        return FunctionExpression("regexp_extract_all", col0, col1, col2, col3)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("regexp_extract_all", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def regexp_full_match(col1, col0, col2=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("regexp_full_match", col0, col1, col2)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("regexp_full_match", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def regexp_matches(col1, col0, col2=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("regexp_matches", col0, col1, col2)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("regexp_matches", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def regexp_replace(col2, col1, col0, col3=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None and col3 is not None:
        return FunctionExpression("regexp_replace", col0, col1, col2, col3)
    elif col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("regexp_replace", col0, col1, col2)
    else:
        raise ValueError('Invalid combination of parameters')


def regexp_split_to_array(string, separator, col2=None, /) -> FunctionExpression:
    """Splits the string along the regex"""
    if string is not None and separator is not None:
        return FunctionExpression("regexp_split_to_array", string, separator)
    elif string is not None and separator is not None and col2 is not None:
        return FunctionExpression("regexp_split_to_array", string, separator, col2)
    else:
        raise ValueError('Invalid combination of parameters')


def regr_avgx(y, x, /) -> FunctionExpression:
    """Returns the average of the independent variable for non-null pairs in a group,
    where x is the independent variable and y is the dependent variable."""
    return FunctionExpression("regr_avgx", y, x)


def regr_avgy(y, x, /) -> FunctionExpression:
    """Returns the average of the dependent variable for non-null pairs in a group,
    where x is the independent variable and y is the dependent variable."""
    return FunctionExpression("regr_avgy", y, x)


def regr_count(y, x, /) -> FunctionExpression:
    """Returns the number of non-null number pairs in a group."""
    return FunctionExpression("regr_count", y, x)


def regr_intercept(y, x, /) -> FunctionExpression:
    """Returns the intercept of the univariate linear regression line for non-null
    pairs in a group."""
    return FunctionExpression("regr_intercept", y, x)


def regr_r2(y, x, /) -> FunctionExpression:
    """Returns the coefficient of determination for non-null pairs in a group."""
    return FunctionExpression("regr_r2", y, x)


def regr_slope(y, x, /) -> FunctionExpression:
    """Returns the slope of the linear regression line for non-null pairs in a group."""
    return FunctionExpression("regr_slope", y, x)


def regr_sxx(y, x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("regr_sxx", y, x)


def regr_sxy(y, x, /) -> FunctionExpression:
    """Returns the population covariance of input values"""
    return FunctionExpression("regr_sxy", y, x)


def regr_syy(y, x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("regr_syy", y, x)


def repeat(string, count, /) -> FunctionExpression:
    """Repeats the string count number of times"""
    return FunctionExpression("repeat", string, count)


def replace(source, string, target, /) -> FunctionExpression:
    """Replaces any occurrences of the source with target in string"""
    return FunctionExpression("replace", source, string, target)


def reservoir_quantile(quantile, x, sample_size=None, /) -> FunctionExpression:
    """Gives the approximate quantile using reservoir sampling, the sample size is
    optional and uses 8192 as a default size."""
    if x is not None and quantile is not None and sample_size is not None:
        return FunctionExpression("reservoir_quantile", x, quantile, sample_size)
    elif x is not None and quantile is not None:
        return FunctionExpression("reservoir_quantile", x, quantile)
    else:
        raise ValueError('Invalid combination of parameters')


def reverse(string, /) -> FunctionExpression:
    """Reverses the string"""
    return FunctionExpression("reverse", string)


def right(string, count, /) -> FunctionExpression:
    """Extract the right-most count characters"""
    return FunctionExpression("right", string, count)


def right_grapheme(string, count, /) -> FunctionExpression:
    """Extract the right-most count grapheme clusters"""
    return FunctionExpression("right_grapheme", string, count)


def round(x, precision=None, /) -> FunctionExpression:
    """Rounds x to s decimal places"""
    if x is not None:
        return FunctionExpression("round", x)
    elif x is not None and precision is not None:
        return FunctionExpression("round", x, precision)
    else:
        raise ValueError('Invalid combination of parameters')


def round_even(n, x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("round_even", n, x)


def roundbankers(n, x, /) -> FunctionExpression:
    """"""
    return FunctionExpression("roundbankers", n, x)


def row(*args) -> FunctionExpression:
    """Creates an unnamed STRUCT containing the argument values."""
    return FunctionExpression("row", *args)


def row_to_json(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("row_to_json", *args)


def rpad(string, character, count, /) -> FunctionExpression:
    """Pads the string with the character from the right until it has count characters"""
    return FunctionExpression("rpad", string, character, count)


def rtrim(string, characters=None, /) -> FunctionExpression:
    """Removes any occurrences of any of the characters from the right side of the
    string"""
    if string is not None:
        return FunctionExpression("rtrim", string)
    elif string is not None and characters is not None:
        return FunctionExpression("rtrim", string, characters)
    else:
        raise ValueError('Invalid combination of parameters')


def second(ts, /) -> FunctionExpression:
    """Extract the second component from a date or timestamp"""
    return FunctionExpression("second", ts)


def sem(x, /) -> FunctionExpression:
    """Returns the standard error of the mean"""
    return FunctionExpression("sem", x)


def session_user() -> FunctionExpression:
    """"""
    return FunctionExpression("session_user")


def set_bit(index, new_value, bitstring, /) -> FunctionExpression:
    """Sets the nth bit in bitstring to newvalue; the first (leftmost) bit is indexed
    0. Returns a new bitstring"""
    return FunctionExpression("set_bit", index, new_value, bitstring)


def setseed() -> FunctionExpression:
    """Sets the seed to be used for the random function"""
    return FunctionExpression("setseed")


def sha256(value, /) -> FunctionExpression:
    """Returns the SHA256 hash of the value"""
    return FunctionExpression("sha256", value)


def sha3(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None:
        return FunctionExpression("sha3", col0, col1)
    elif col0 is not None:
        return FunctionExpression("sha3", col0)
    else:
        raise ValueError('Invalid combination of parameters')


def sha3_query(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None:
        return FunctionExpression("sha3_query", col0)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("sha3_query", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def shell_add_schema(col2, col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("shell_add_schema", col2, col1, col0)


def shell_escape_crnl(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("shell_escape_crnl", col0)


def shell_idquote(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("shell_idquote", col0)


def shell_int32(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("shell_int32", col1, col0)


def shell_module_schema(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("shell_module_schema", col0)


def shell_putsnl(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("shell_putsnl", col0)


def shobj_description(catalog_name, object_oid, /) -> FunctionExpression:
    """"""
    return FunctionExpression("shobj_description", catalog_name, object_oid)


def sign(x, /) -> FunctionExpression:
    """Returns the sign of x as -1, 0 or 1"""
    return FunctionExpression("sign", x)


def signbit(x, /) -> FunctionExpression:
    """Returns whether the signbit is set or not"""
    return FunctionExpression("signbit", x)


def sin(x, /) -> FunctionExpression:
    """Computes the sin of x"""
    return FunctionExpression("sin", x)


def skewness(x, /) -> FunctionExpression:
    """Returns the skewness of all input values."""
    return FunctionExpression("skewness", x)


def split(string, separator, /) -> FunctionExpression:
    """Splits the string along the separator"""
    return FunctionExpression("split", string, separator)


def split_part(delimiter, string, position, /) -> FunctionExpression:
    """"""
    return FunctionExpression("split_part", delimiter, string, position)


def sqrt(x, /) -> FunctionExpression:
    """Returns the square root of x"""
    return FunctionExpression("sqrt", x)


def starts_with(string, search_string, /) -> FunctionExpression:
    """Returns true if string begins with search_string"""
    return FunctionExpression("starts_with", string, search_string)


def stats(expression, /) -> FunctionExpression:
    """Returns a string with statistics about the expression. Expression can be a
    column, constant, or SQL expression"""
    return FunctionExpression("stats", expression)


def stddev(x, /) -> FunctionExpression:
    """Returns the sample standard deviation"""
    return FunctionExpression("stddev", x)


def stddev_pop(x, /) -> FunctionExpression:
    """Returns the population standard deviation."""
    return FunctionExpression("stddev_pop", x)


def stddev_samp(x, /) -> FunctionExpression:
    """Returns the sample standard deviation"""
    return FunctionExpression("stddev_samp", x)


def str_split(string, separator, /) -> FunctionExpression:
    """Splits the string along the separator"""
    return FunctionExpression("str_split", string, separator)


def str_split_regex(string, separator, col2=None, /) -> FunctionExpression:
    """Splits the string along the regex"""
    if string is not None and separator is not None:
        return FunctionExpression("str_split_regex", string, separator)
    elif string is not None and separator is not None and col2 is not None:
        return FunctionExpression("str_split_regex", string, separator, col2)
    else:
        raise ValueError('Invalid combination of parameters')


def strftime(text, format, /) -> FunctionExpression:
    """Converts timestamp to string according to the format string"""
    return FunctionExpression("strftime", text, format)


def string_agg(str, arg=None, /) -> FunctionExpression:
    """Concatenates the column string values with an optional separator."""
    if str is not None:
        return FunctionExpression("string_agg", str)
    elif str is not None and arg is not None:
        return FunctionExpression("string_agg", str, arg)
    else:
        raise ValueError('Invalid combination of parameters')


def string_split(string, separator, /) -> FunctionExpression:
    """Splits the string along the separator"""
    return FunctionExpression("string_split", string, separator)


def string_split_regex(string, separator, col2=None, /) -> FunctionExpression:
    """Splits the string along the regex"""
    if string is not None and separator is not None and col2 is not None:
        return FunctionExpression("string_split_regex", string, separator, col2)
    elif string is not None and separator is not None:
        return FunctionExpression("string_split_regex", string, separator)
    else:
        raise ValueError('Invalid combination of parameters')


def string_to_array(string, separator, /) -> FunctionExpression:
    """Splits the string along the separator"""
    return FunctionExpression("string_to_array", string, separator)


def strip_accents(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("strip_accents", col0)


def strlen(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("strlen", col0)


def strpos(haystack, needle, /) -> FunctionExpression:
    """Returns location of first occurrence of needle in haystack, counting from 1.
    Returns 0 if no match found"""
    return FunctionExpression("strpos", haystack, needle)


def strptime(text, format, /) -> FunctionExpression:
    """Converts string to timestamp with time zone according to the format string if %Z
    is specified"""
    return FunctionExpression("strptime", text, format)


def struct_extract(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("struct_extract", col1, col0)


def struct_insert(*args) -> FunctionExpression:
    """Adds field(s)/value(s) to an existing STRUCT with the argument values. The entry
    name(s) will be the bound variable name(s)"""
    return FunctionExpression("struct_insert", *args)


def struct_pack(*args) -> FunctionExpression:
    """Creates a STRUCT containing the argument values. The entry name will be the
    bound variable name"""
    return FunctionExpression("struct_pack", *args)


def substr(col1, col0, col2=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("substr", col0, col1, col2)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("substr", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def substring(col1, col0, col2=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("substring", col0, col1, col2)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("substring", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def substring_grapheme(col1, col0, col2=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None and col2 is not None:
        return FunctionExpression("substring_grapheme", col0, col1, col2)
    elif col0 is not None and col1 is not None:
        return FunctionExpression("substring_grapheme", col0, col1)
    else:
        raise ValueError('Invalid combination of parameters')


def subtract(col0, col1=None, /) -> FunctionExpression:
    """"""
    if col0 is not None and col1 is not None:
        return FunctionExpression("subtract", col0, col1)
    elif col0 is not None:
        return FunctionExpression("subtract", col0)
    else:
        raise ValueError('Invalid combination of parameters')


def suffix(col1, col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("suffix", col1, col0)


def sum(arg, /) -> FunctionExpression:
    """Calculates the sum value for all tuples in arg."""
    return FunctionExpression("sum", arg)


def sum_no_overflow(arg, /) -> FunctionExpression:
    """Calculates the sum value for all tuples in arg without overflow checks."""
    return FunctionExpression("sum_no_overflow", arg)


def sumkahan(arg, /) -> FunctionExpression:
    """Calculates the sum using a more accurate floating point summation (Kahan Sum)."""
    return FunctionExpression("sumkahan", arg)


def tan(x, /) -> FunctionExpression:
    """Computes the tan of x"""
    return FunctionExpression("tan", x)


def time_bucket(bucket_width, timestamp, origin=None, /) -> FunctionExpression:
    """Truncate TIMESTAMPTZ by the specified interval bucket_width. Buckets are aligned
    relative to origin TIMESTAMPTZ. The origin defaults to 2000-01-03
    00:00:00+00 for buckets that do not include a month or year interval, and to
    2000-01-01 00:00:00+00 for month and year buckets"""
    if bucket_width is not None and timestamp is not None:
        return FunctionExpression("time_bucket", bucket_width, timestamp)
    elif bucket_width is not None and timestamp is not None and origin is not None:
        return FunctionExpression("time_bucket", bucket_width, timestamp, origin)
    else:
        raise ValueError('Invalid combination of parameters')


def timezone(ts, col1=None, /) -> FunctionExpression:
    """Extract the timezone component from a date or timestamp"""
    if ts is not None and col1 is not None:
        return FunctionExpression("timezone", ts, col1)
    elif ts is not None:
        return FunctionExpression("timezone", ts)
    else:
        raise ValueError('Invalid combination of parameters')


def timezone_hour(ts, /) -> FunctionExpression:
    """Extract the timezone_hour component from a date or timestamp"""
    return FunctionExpression("timezone_hour", ts)


def timezone_minute(ts, /) -> FunctionExpression:
    """Extract the timezone_minute component from a date or timestamp"""
    return FunctionExpression("timezone_minute", ts)


def to_base(number, radix, min_length=None, /) -> FunctionExpression:
    """Converts a value to a string in the given base radix, optionally padding with
    leading zeros to the minimum length"""
    if number is not None and radix is not None and min_length is not None:
        return FunctionExpression("to_base", number, radix, min_length)
    elif number is not None and radix is not None:
        return FunctionExpression("to_base", number, radix)
    else:
        raise ValueError('Invalid combination of parameters')


def to_base64(blob, /) -> FunctionExpression:
    """Convert a blob to a base64 encoded string"""
    return FunctionExpression("to_base64", blob)


def to_binary(value, /) -> FunctionExpression:
    """Converts the value to binary representation"""
    return FunctionExpression("to_binary", value)


def to_days(integer, /) -> FunctionExpression:
    """Construct a day interval"""
    return FunctionExpression("to_days", integer)


def to_hex(value, /) -> FunctionExpression:
    """Converts the value to hexadecimal representation"""
    return FunctionExpression("to_hex", value)


def to_hours(integer, /) -> FunctionExpression:
    """Construct a hour interval"""
    return FunctionExpression("to_hours", integer)


def to_json(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("to_json", *args)


def to_microseconds(integer, /) -> FunctionExpression:
    """Construct a microsecond interval"""
    return FunctionExpression("to_microseconds", integer)


def to_milliseconds(integer, /) -> FunctionExpression:
    """Construct a millisecond interval"""
    return FunctionExpression("to_milliseconds", integer)


def to_minutes(integer, /) -> FunctionExpression:
    """Construct a minute interval"""
    return FunctionExpression("to_minutes", integer)


def to_months(integer, /) -> FunctionExpression:
    """Construct a month interval"""
    return FunctionExpression("to_months", integer)


def to_seconds(integer, /) -> FunctionExpression:
    """Construct a second interval"""
    return FunctionExpression("to_seconds", integer)


def to_timestamp(sec, /) -> FunctionExpression:
    """Converts secs since epoch to a timestamp with time zone"""
    return FunctionExpression("to_timestamp", sec)


def to_years(integer, /) -> FunctionExpression:
    """Construct a year interval"""
    return FunctionExpression("to_years", integer)


def today() -> FunctionExpression:
    """Returns the current date"""
    return FunctionExpression("today")


def transaction_timestamp() -> FunctionExpression:
    """Returns the current timestamp"""
    return FunctionExpression("transaction_timestamp")


def translate(from_, string, to, /) -> FunctionExpression:
    """Replaces each character in string that matches a character in the from set with
    the corresponding character in the to set. If from is longer than to,
    occurrences of the extra characters in from are deleted"""
    return FunctionExpression("translate", from_, string, to)


def trim(string, characters=None, /) -> FunctionExpression:
    """Removes any occurrences of any of the characters from either side of the string"""
    if string is not None:
        return FunctionExpression("trim", string)
    elif string is not None and characters is not None:
        return FunctionExpression("trim", string, characters)
    else:
        raise ValueError('Invalid combination of parameters')


def trunc(x, /) -> FunctionExpression:
    """Truncates the number"""
    return FunctionExpression("trunc", x)


def try_strptime(text, format, /) -> FunctionExpression:
    """Converts string to timestamp using the format string (timestamp with time zone
    if %Z is specified). Returns NULL on failure"""
    return FunctionExpression("try_strptime", text, format)


def txid_current() -> FunctionExpression:
    """Returns the current transaction’s ID (a BIGINT). It will assign a new one if the
    current transaction does not have one already"""
    return FunctionExpression("txid_current")


def typeof(expression, /) -> FunctionExpression:
    """Returns the name of the data type of the result of the expression"""
    return FunctionExpression("typeof", expression)


def ucase(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("ucase", col0)


def unbin(value, /) -> FunctionExpression:
    """Converts a value from binary representation to a blob"""
    return FunctionExpression("unbin", value)


def unhex(value, /) -> FunctionExpression:
    """Converts a value from hexadecimal representation to a blob"""
    return FunctionExpression("unhex", value)


def unicode(str, /) -> FunctionExpression:
    """Returns the unicode codepoint of the first character of the string"""
    return FunctionExpression("unicode", str)


def union_extract(union, tag, /) -> FunctionExpression:
    """Extract the value with the named tags from the union. NULL if the tag is not
    currently selected"""
    return FunctionExpression("union_extract", union, tag)


def union_tag(union, /) -> FunctionExpression:
    """Retrieve the currently selected tag of the union as an ENUM"""
    return FunctionExpression("union_tag", union)


def union_value(*args) -> FunctionExpression:
    """Create a single member UNION containing the argument value. The tag of the value
    will be the bound variable name"""
    return FunctionExpression("union_value", *args)


def upper(col0, /) -> FunctionExpression:
    """"""
    return FunctionExpression("upper", col0)


def user() -> FunctionExpression:
    """"""
    return FunctionExpression("user")


def uuid() -> FunctionExpression:
    """Returns a random UUID similar to this: eeccb8c5-9943-b2bb-bb5e-222f4e14b687"""
    return FunctionExpression("uuid")


def var_pop(x, /) -> FunctionExpression:
    """Returns the population variance."""
    return FunctionExpression("var_pop", x)


def var_samp(x, /) -> FunctionExpression:
    """Returns the sample variance of all input values."""
    return FunctionExpression("var_samp", x)


def variance(x, /) -> FunctionExpression:
    """Returns the sample variance of all input values."""
    return FunctionExpression("variance", x)


def vector_type(col, /) -> FunctionExpression:
    """Returns the VectorType of a given column"""
    return FunctionExpression("vector_type", col)


def version() -> FunctionExpression:
    """Returns the currently active version of DuckDB in this format: v0.3.2"""
    return FunctionExpression("version")


def week(ts, /) -> FunctionExpression:
    """Extract the week component from a date or timestamp"""
    return FunctionExpression("week", ts)


def weekday(ts, /) -> FunctionExpression:
    """Extract the weekday component from a date or timestamp"""
    return FunctionExpression("weekday", ts)


def weekofyear(ts, /) -> FunctionExpression:
    """Extract the weekofyear component from a date or timestamp"""
    return FunctionExpression("weekofyear", ts)


def writefile(*args) -> FunctionExpression:
    """"""
    return FunctionExpression("writefile", *args)


def xor(right, left, /) -> FunctionExpression:
    """Bitwise XOR"""
    return FunctionExpression("xor", right, left)


def year(ts, /) -> FunctionExpression:
    """Extract the year component from a date or timestamp"""
    return FunctionExpression("year", ts)


def yearweek(ts, /) -> FunctionExpression:
    """Extract the yearweek component from a date or timestamp"""
    return FunctionExpression("yearweek", ts)
